---
icon: simple/fastapi
tags:
  - fastapi
  - pydantic
  - sqlite
hide:
  - navigation
---

# Configuração do BD


```bash title="Condiguração do ambiente"
poetry add pydantic-settings
poetry add sqlalchemy
```

<!--  
No repo do projeto no vscodium implementei isso: https://fastapidozero.dunossauro.com/estavel/04/
Não fiz nada de testes nem usarei o Alembic
-->
Estrutura do projeto:
``` hl_lines="1 2 4 5 10"
├── .env
├── app.py
├── database.db
├── database.py
├── models.py
├── poetry.lock
├── pyproject.toml
├── README.md
├── schemas.py
├── settings.py
└── tests
```

Essa configuração realiza a transição de um armazenamento volátil em memória para a persistência de dados, utilizando o **SQLAlchemy 2.0** e o **Pydantic Settings** para estruturar uma base de dados SQLite. O processo organiza a aplicação em camadas: o `settings.py` valida as variáveis de ambiente, o `models.py` define a estrutura das tabelas através do registro de mapeamento moderno (`mapeador`), e o `database.py` estabelece a conexão e o gerenciamento de sessões, garantindo que os dados sejam preservados após o reinício do servidor e manipulados de maneira segura e eficiente.

``` python title="settings.py"
from pydantic_settings import BaseSettings, SettingsConfigDict # (1)!


class Settings(BaseSettings): # (2)!
    model_config = SettingsConfigDict( 
        env_file='.env', env_file_encoding='utf-8'
    )

    DATABASE_URL: str # (3)!
```

1. `BaseSettings` é uma classe do Pydantic que permite carregar e validar variáveis de ambiente facilmente, garantindo configurações seguras e organizadas. `SettingsConfigDict` personaliza o comportamento da `BaseSettings`, como especificar o arquivo `.env` e a codificação. Juntas, elas simplificam a gestão de configurações na aplicação
2. Essa classe `Settings` herda de `BaseSettings`, permitindo que você configure variáveis de ambiente. O `model_config` define que o Pydantic deve carregar as configurações do arquivo `.env`, usando a codificação UTF-8
3. `DATABASE_URL: str` é uma variável de ambiente que armazena a URL do banco de dados, isso indica que essa variável deve ser lida como uma string

O `settings.py` utiliza o arquivo `.env` para obter o valor de variáveis como `DATABASE_URL`. A definição `DATABASE_URL: str` indica que essa variável deve ser lida como uma string. Quando a aplicação é iniciada, o Pydantic busca automaticamente no arquivo `.env` por essa variável e a valida para garantir que está presente e é do tipo correto, permitindo que você configure de forma segura e eficiente.

``` python title=".env"
DATABASE_URL="sqlite:///database.db" # (1)!
```

1. Esse valor permite que a aplicação saiba onde e como se conectar ao banco de dados adequado durante a execução:
`DATABASE_URL`: é o nome da variável que será utilizada no `settings.py` para acessar a URL do banco de dados.
`"sqlite:///database.db"`: é a URL de conexão para um banco de dados SQLite localizado no arquivo `database.db`. O formato `sqlite:///` indica que você está utilizando o SQLite como sistema de gerenciamento de banco de dados.


Com o endereço do banco de dados corretamente configurado nas variáveis de ambiente, o próximo passo é definir a estrutura da tabela. No arquivo `models.py`, especificamos como os dados serão organizados no SQLite utilizando o sistema de mapeamento do SQLAlchemy.



``` python title="models.py"
from datetime import datetime # (1)!
from sqlalchemy import func # (2)!
from sqlalchemy.orm import Mapped, mapped_as_dataclass, mapped_column, registry # (3)!

mapeador = registry() # (4)!

@mapped_as_dataclass(mapeador) # (5)!
class User:
    __tablename__ = 'users'

    id: Mapped[int] = mapped_column(init=False, primary_key=True) # (6)!
    username: Mapped[str] = mapped_column(unique=True) # (7)!
    password: Mapped[str]
    email: Mapped[str] = mapped_column(unique=True)
    created_at: Mapped[datetime] = mapped_column(
        init=False, server_default=func.now() # (8)!
    )
```

1. Importa a classe `datetime`, que é utilizada para manipular datas e horas, como no campo `created_at`.
2. Importa a funcionalidade `func`, que permite utilizar funções do SQL, como `func.now()` para definir o timestamp de criação automaticamente.
3. `Mapped`: Tipo que indica que um atributo da classe está mapeado para uma coluna no banco de dados.
`mapped_as_dataclass`: Decorador que transforma uma classe em uma dataclass, facilitando o uso de características do Python modernas.
`mapped_column`: Utilizado para definir colunas em uma tabela mapeada, especificando aspectos como tipo e restrições.
`registry`: Utilizado para registrar tabelas e classes, permitindo que o SQLAlchemy saiba como mapear a estrutura de sua aplicação para o banco de dados.
4. Cria uma instância do `registry` do SQLAlchemy, que organiza e registra tabelas e classes mapeadas para o banco de dados, facilitando a manutenção e o mapeamento de dados.
5. A linha `@mapped_as_dataclass(mapeador)` transforma a classe `User` em uma dataclass, registrando-a no SQLAlchemy através do `mapeador`, enquanto `__tablename__ = 'users'` define o nome da tabela correspondente no banco de dados como `users`, permitindo que a classe interaja como um modelo de dados estruturado. Uma dataclass é um recurso do Python (introduzido na versão 3.7) que simplifica a criação de classes voltadas para o armazenamento de dados.
6. Define a coluna `id` na tabela do banco de dados como um inteiro mapeado, onde `Mapped[int]` indica o tipo de dado, `mapped_column` configura suas características: `init=False` significa que não será incluído no construtor da dataclass, e `primary_key=True` especifica que essa coluna é a chave primária, garantindo valores únicos e não nulos.
7. `unique=True` indica que todos os valores dessa coluna devem ser únicos, ou seja, não pode haver duplicatas. 
8. A expressão `server_default=func.now()` define um valor padrão para a coluna `created_at`, utilizando a função `now()` do SQLAlchemy, que corresponde à função SQL `NOW()`. Isso significa que, ao inserir um novo registro, a coluna será automaticamente preenchida com a data e hora atuais do servidor, eliminando a necessidade de definir esse valor manualmente.

Com a estrutura da tabela de usuários registrada pelo mapeador, é necessário estabelecer o fluxo de dados para direcionar esses dados para o arquivo de destino. No módulo `database.py`, configuramos o motor de conexão e implementamos a função que fornecerá as sessões de trabalho para as rotas da aplicação.

``` python title="database.py"
from sqlalchemy import create_engine # (1)!
from sqlalchemy.orm import Session # (2)!
from settings import Settings # (3)!

conexao = create_engine(Settings().DATABASE_URL) # (4)!

def get_session(): # (5)!
    with Session(conexao) as session:
        yield session
```

1. Importa a função `create_engine`, que é usada para configurar a conexão com o banco de dados, criando uma instância de `conexao` para interagir com ele.
2. Importa a classe `Session`, que permite gerenciar transações e operações de consulta ao banco de dados de forma organizada.
3. Importa a classe `Settings` do módulo `settings`, que é utilizada para acessar as configurações, como a URL do banco de dados, garantindo que as credenciais e outras informações sensíveis sejam geridas de forma segura.
4. Cria uma instância de `conexao`, que representa a conexão com o banco de dados, utilizando a URL de conexão obtida da classe `Settings`.
5. A função `get_session()` é um gerador que cria e gerencia uma sessão do banco de dados, utilizando o `conexao` para abrir a sessão com `Session(conexao)`. O uso do `with` garante que a sessão será fechada automaticamente após o uso, enquanto o `yield session` permite que a sessão seja utilizada para operações no banco de dados, retornando o controle após a conclusão e assegurando a limpeza adequada dos recursos.

Por fim, integrando todos os componentes no núcleo da aplicação, o `app.py` permite que o motor de conexão utilize a estrutura do mapeador para inicializar o banco de dados, enquanto as rotas requerem uma sessão ativa para executar operações reais de leitura e escrita.

  ``` python title="app.py" hl_lines="12"
  from http import HTTPStatus
  from fastapi import FastAPI, HTTPException, Depends
  from schemas import UserSchema, UserPublic, UserList, Message, UserUpdate
  from sqlalchemy import select
  from sqlalchemy.orm import Session

  from database import get_session, conexao
  from models import User, mapeador

  app = FastAPI()

  mapeador.metadata.create_all(bind=conexao) # (1)!

  # rotas ...
  ```

  1. Cria todas as tabelas definidas no mapeador no banco de dados usando a conexão fornecida pelo `conexao`. O `mapeador.metadata` contém informações sobre as tabelas e colunas mapeadas, e o método `create_all(...)` solicita a criação das tabelas que ainda não existem, garantindo que a estrutura do banco de dados esteja pronta para uso. Na sintaxe `bind=conexao`, o parâmetro `bind` refere-se à conexão que será usada para executar a operação de criação das tabelas no banco de dados.