---
icon: simple/fastapi
---

# 02 CRUD: POST e GET

??? abstract "Referências"

    - [Pydantic](https://docs.pydantic.dev/latest/)

Estrutura do projeto:
```
└── fast_zero
    ├── app.py
    ├── fast_zero
    ├── poetry.lock
    ├── pyproject.toml
    ├── schemas.py
    └── tests
        └── __init__.py
```

<!-- linenums="1" -->
``` python hl_lines="15-26" title="app.py"
from fastapi import FastAPI
from schemas import UserSchema, UserResponse, UserDB, UserList

app = FastAPI() # (1)!

@app.get("/") # (2)!
def read_root():
    return {'message': 'API FUNCIONANDO!'}

database = [] # (3)!

@app.post("/users/", status_code=201, response_model=UserResponse)# (4)!
def create_user(user: UserSchema):

    dados_do_usuario = user.model_dump() # (5)!
    
    novo_id = len(database) + 1 # (6)!

    user_with_id = UserDB( # (7)!
        id=novo_id,
        username=dados_do_usuario["username"],
        email=dados_do_usuario["email"],
        password=dados_do_usuario["password"]
    )
    
    database.append(user_with_id) # (8)!
    # (9)!

    return {
        "message": "Usuário criado com sucesso",
        "user": user_with_id
    }

@app.get('/users/', response_model=UserList)
def read_users():
    return {'users': database} # (10)!
```

1. Criamos a instância do FastAPI
2. Dizemos que quando alguém acessar a "raiz" (`/`) via GET, execute esta função: `read_root`
3. Banco de dados "fake" em memória
4. Em `response_model` especifica que a resposta de uma rota deve seguir a estrutura definida pelo modelo `UserResponse`, o que permite validação automática da resposta e documentação automatica
5. `model_dump()` transforma os dados validados enviados para a rota POST em um dicionário simples, permitindo acesso fácil e garantindo que apenas os dados válidos do `UserSchema` sejam incluídos.
6. Calculado o `ID` manualmente baseando-se no tamanho atual da lista
7. Esse trecho cria uma nova instância do modelo `UserDB`, que representa o usuário no "banco de dados", atribuindo a ele um ID gerado (`novo_id`) e preenchendo os campos `username`, `email` e `password` com os dados extraídos do dicionário `dados_do_usuario`.
8. Adiciona o objeto `user_with_id`, que representa um novo usuário, à lista `database`. Isso simula o armazenamento do usuário no "banco de dados", que, neste caso, é apenas uma lista em memória, permitindo que os dados dos usuários sejam mantidos e acessados posteriormente.
9. O destaque acima poderia ser substituído por essas duas linhas:
    ``` python
    user_with_id = UserDB(**user.model_dump(), id=len(database) + 1)  
    database.append(user_with_id)
    ```
    Ao usar `**user.model_dump()`, o operador `**` desempacota o dicionário resultante, permitindo que seus pares chave-valor sejam passados como argumentos nomeados para uma função ou construtor, como em `UserDB()`
10. Retorna um dicionário com a chave `users` e a lista `database` como valor, representando todos os usuários armazenados

O arquivo abaixo contém as definições de schemas de dados utilizando o Pydantic, que são essenciais para validar e estruturar as informações utilizadas na aplicação FastAPI definida em `app.py`.

As classes definidas no arquivo servem como modelos que especificam os atributos e seus tipos para os dados utilizados na aplicação, utilizando o Pydantic. Cada classe define campos, como `username`, `email`, e `password`, e seus tipos correspondentes (por exemplo, `str` e `EmailStr`), garantindo que os dados sejam automaticamente validados e estruturados de maneira consistente ao interagir com a API.

``` python title="schemas.py"
from pydantic import BaseModel, EmailStr # (2)!

class UserSchema(BaseModel):
    username: str
    email: EmailStr
    password: str

class UserPublic(BaseModel):
    username: str
    email: EmailStr

class UserResponse(BaseModel):
    message: str
    user: UserPublic

class UserDB(UserSchema): # (1)!
    id: int

class UserList(BaseModel):
    users: list[UserPublic]
```

1. Indica que a classe `UserDB` herda da classe `UserSchema`. Isso significa que `UserDB` possui todos os atributos e validações definidos em `UserSchema`, além de adicionar um novo atributo, `id`, do tipo `int`. Essa herança permite que `UserDB` aproveite a estrutura e a validação de dados já configuradas em `UserSchema`, facilitando a criação de modelos de dados mais especializados.
2. `BaseModel` é uma classe do Pydantic que permite criar modelos de dados, oferecendo validação automática, fácil conversão para JSON e aprimoramento na documentação de APIs. É essencial para construir modelos consistentes e validados.